const fs = require('fs');
const path = require('path');

class RecapGenerator {
    constructor(governor) {
        this.governor = governor;
    }

    async generateRecap() {
        const state = this.governor.loadState();
        if (!state) return { error: "Could not load state" };

        const now = new Date();
        const last24h = new Date(now.getTime() - (24 * 60 * 60 * 1000));

        const completedTasks = state.backlog.filter(t => {
            return t.status === 'completed' && new Date(t.completedAt) > last24h;
        });

        if (completedTasks.length === 0) {
            return { message: "No tasks completed in the last 24 hours." };
        }

        let markdown = `# Technical Recap - ${now.toISOString().split('T')[0]}\n\n`;
        markdown += `## üöÄ Completed Tasks (${completedTasks.length})\n\n`;

        completedTasks.forEach(task => {
            markdown += `### ${task.title}\n`;
            markdown += `- **ID:** \`${task.id}\`\n`;
            markdown += `- **Completed At:** ${task.completedAt}\n`;
            markdown += `- **Result:** ${task.result || 'No summary provided'}\n`;
            markdown += `- **Impact Analysis:** ${this._generateImpactAnalysis(task)}\n\n`;
        });

        // Add analytics summary
        const analytics = this.governor.analytics.getSummary();
        const dateKey = now.toISOString().split('T')[0];
        const dailyStats = analytics.daily[dateKey] || { apiCalls: 0, tokens: 0, tasksCompleted: 0 };

        markdown += `## üìä Daily Metrics\n`;
        markdown += `- **API Calls:** ${dailyStats.apiCalls}\n`;
        markdown += `- **Tokens Consumed:** ${dailyStats.tokens}\n`;
        markdown += `- **Tasks Finished:** ${dailyStats.tasksCompleted}\n\n`;
        
        markdown += `*Generated by Zown Governor*\n`;

        const reportPath = path.join(process.cwd(), 'memory', 'reports', `recap-${dateKey}.md`);
        
        // Ensure directory exists
        const reportsDir = path.dirname(reportPath);
        if (!fs.existsSync(reportsDir)) {
            fs.mkdirSync(reportsDir, { recursive: true });
        }

        fs.writeFileSync(reportPath, markdown);

        return {
            message: "Recap generated successfully",
            path: reportPath,
            summary: this._generateDiscordSummary(completedTasks, dailyStats)
        };
    }

    _generateImpactAnalysis(task) {
        // Placeholder for heuristic-based impact analysis
        if (task.priority === 'critical' || task.priority === 'high') {
            return "Strategic advancement in core infrastructure.";
        }
        return "Incremental improvement to system stability and efficiency.";
    }

    _generateDiscordSummary(tasks, stats) {
        return `**Technical Recap Generated** üèóÔ∏è\n` +
               `- **Tasks Completed:** ${tasks.length}\n` +
               `- **API Load:** ${stats.apiCalls} calls\n` +
               `- **Top Task:** ${tasks[0].title}\n` +
               `*Full report saved to memory/reports/*`;
    }
}

module.exports = RecapGenerator;
